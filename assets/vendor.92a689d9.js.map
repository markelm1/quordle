{"version":3,"file":"vendor.92a689d9.js","sources":["../../node_modules/solid-js/dist/solid.js","../../node_modules/solid-js/web/dist/web.js","../../node_modules/solid-app-router/dist/integration.js","../../node_modules/solid-app-router/dist/utils.js","../../node_modules/solid-app-router/dist/routing.js","../../node_modules/solid-app-router/dist/components.jsx","../../node_modules/mersenne-twister/src/mersenne-twister.js","../../node_modules/solid-js/store/dist/store.js","../../node_modules/file-saver/dist/FileSaver.min.js","../../node_modules/solid-dismiss/dist/source/browserInfo.js","../../node_modules/solid-dismiss/dist/source/global/dismissStack.js","../../node_modules/solid-dismiss/dist/source/utils/tabbing.js","../../node_modules/solid-dismiss/dist/source/global/globalEvents.js","../../node_modules/solid-dismiss/dist/source/local/outside.js","../../node_modules/solid-dismiss/dist/source/local/menuButton.js","../../node_modules/solid-dismiss/dist/source/utils/index.js","../../node_modules/solid-dismiss/dist/source/local/menuPopup.js","../../node_modules/solid-dismiss/dist/source/components/CreatePortal.js","../../node_modules/solid-dismiss/dist/source/components/Transition.js","../../node_modules/solid-dismiss/dist/source/local/manageLocalEvents.js","../../node_modules/solid-dismiss/dist/source/local/container.js","../../node_modules/solid-dismiss/dist/source/local/overlay.js","../../node_modules/solid-dismiss/dist/source/local/focusSentinel.js","../../node_modules/solid-dismiss/dist/source/index.jsx","../../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js","../../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js","../../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js","../../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","../../node_modules/@juggle/resize-observer/lib/utils/freeze.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js","../../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js","../../node_modules/@juggle/resize-observer/lib/utils/element.js","../../node_modules/@juggle/resize-observer/lib/utils/global.js","../../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","../../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js","../../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js","../../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js","../../node_modules/@juggle/resize-observer/lib/utils/process.js","../../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js","../../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js","../../node_modules/@juggle/resize-observer/lib/utils/scheduler.js","../../node_modules/@juggle/resize-observer/lib/ResizeObservation.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserver.js"],"sourcesContent":["let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}.`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  detachedOwner && (Owner = detachedOwner);\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner\n  };\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(() => fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : queueMicrotask(() => updateComputation(c));\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  if (options.globalRefetch !== false) {\n    Resources || (Resources = new Set());\n    Resources.add(load);\n    Owner && onCleanup(() => Resources.delete(load));\n  }\n  const contexts = new Set(),\n        [s, set] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      dynamic = typeof source === \"function\";\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      if (initP && p === initP && options.onHydrated) options.onHydrated(key, {\n        value: v\n      });\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      set(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = s();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? source() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(s));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: s(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: set\n  }];\n}\nlet Resources;\nfunction refetchResources(info) {\n  return Resources && Promise.all([...Resources].map(fn => fn(info)));\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== (p !== undefined && fn(key, p))) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.size > 1 ? l.delete(listener) : subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn,\noptions) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = [];\n      for (let i = 0; i < deps.length; i++) input.push(deps[i]());\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  return lookup(Owner, context.id) || context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookDownstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (o.pure) Updates.push(o);else Effects.push(o);\n        if (o.observers && (TransitionRunning && !o.tState || !TransitionRunning && !o.state)) markUpstream(o);\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state !== STALE) return node.state = 0;\n  if (runningTransition && node.tState !== STALE) return node.tState = 0;\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookDownstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    completeUpdates(wait);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    res = Transition.resolve;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookDownstream(node, ignore) {\n  node.state = 0;\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookDownstream(source, ignore);\n    }\n  }\n}\nfunction markUpstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markUpstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\nfunction lookup(owner, key) {\n  return owner && (owner.context && owner.context[key] !== undefined ? owner.context[key] : owner.owner && lookup(owner.owner, key));\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = \"next\" in observer ? observer.next : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n      };\n    },\n    [$$observable]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return typeof s === \"function\" ? s() : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default), {\n        globalRefetch: false\n      });\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl:${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err = undefined;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count);\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  let e;\n  return createMemo(() => {\n    if ((e = errored()) != null) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(null))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if (error = err) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = untrack(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered;\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, refetchResources, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { createMemo, createRoot, createRenderEffect, sharedConfig, enableHydration, createSignal, onCleanup, splitProps, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst PropAliases = {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n};\nconst DelegatedEvents = new Set([\"beforeinput\", \"click\", \"dblclick\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    node.addEventListener(name, e => handler[0](handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  if (value == null || typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (prev = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}) {\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      assignProp(node, prop, null, prevProps[prop], isSVG);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    node.addEventListener(prop.slice(3), value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    node.addEventListener(prop.slice(10), value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    addEventListener(node, name, value, delegate);\n    delegate && delegateEvents([name]);\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler(data, e) : handler(e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps));\n  return prevProps;\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    if (normalizeIncomingArray(array, value, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context && current && current.length) {\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n      return current;\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (Array.isArray(current)) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context) return current = value.parentNode ? multi ? [value] : value : current;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        t;\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item) || dynamic;\n    } else if ((t = typeof item) === \"string\") {\n      normalized.push(document.createTextNode(item));\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else normalized.push(document.createTextNode(item.toString()));\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if (!root || key.startsWith(root)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction Assets() {\n  return;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction renderToString(fn, options) {}\nfunction renderToStringAsync(fn, options) {}\nfunction renderToStream(fn, options) {}\nfunction ssr(template, ...nodes) {}\nfunction resolveSSRNode(node) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrSpread(accessor) {}\nfunction ssrBoolean(key, value) {}\nfunction ssrHydrationKey() {}\nfunction escape(html) {}\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  return createMemo(() => {\n    const component = p.component;\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, memo, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrBoolean, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };\n","import { createSignal, onCleanup } from \"solid-js\";\nfunction bindEvent(target, type, handler) {\n    target.addEventListener(type, handler);\n    return () => target.removeEventListener(type, handler);\n}\nfunction intercept([value, setValue], get, set) {\n    return [get ? () => get(value()) : value, set ? (v) => setValue(set(v)) : setValue];\n}\nexport function createIntegration(get, set, init, utils) {\n    let ignore = false;\n    const wrap = (value) => (typeof value === \"string\" ? { value } : value);\n    const signal = intercept(createSignal(wrap(get()), { equals: (a, b) => a.value === b.value }), undefined, next => {\n        !ignore && set(next);\n        return next;\n    });\n    init &&\n        onCleanup(init((value = get()) => {\n            ignore = true;\n            signal[1](wrap(value));\n            ignore = false;\n        }));\n    return {\n        signal,\n        utils\n    };\n}\nexport function normalizeIntegration(integration) {\n    if (!integration) {\n        return {\n            signal: createSignal({ value: \"\" })\n        };\n    }\n    else if (Array.isArray(integration)) {\n        return {\n            signal: integration\n        };\n    }\n    return integration;\n}\nexport function staticIntegration(obj) {\n    return {\n        signal: [() => obj, next => Object.assign(obj, next)]\n    };\n}\nexport function pathIntegration() {\n    return createIntegration(() => ({\n        value: window.location.pathname + window.location.search + window.location.hash,\n        state: history.state\n    }), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", value);\n        }\n        else {\n            window.history.pushState(state, \"\", value);\n        }\n        if (scroll) {\n            window.scrollTo(0, 0);\n        }\n    }, notify => bindEvent(window, \"popstate\", () => notify()), {\n        go: delta => window.history.go(delta)\n    });\n}\nexport function hashIntegration() {\n    return createIntegration(() => window.location.hash.slice(1), ({ value, scroll }) => {\n        window.location.hash = value;\n        if (scroll) {\n            window.scrollTo(0, 0);\n        }\n    }, notify => bindEvent(window, \"hashchange\", () => notify()), {\n        go: delta => window.history.go(delta),\n        renderPath: path => `#${path}`\n    });\n}\n","import { createMemo, getOwner, runWithOwner } from \"solid-js\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path) {\n    const s = path.replace(trimPathRegex, \"\");\n    return s ? (s.startsWith(\"?\") ? s : \"/\" + s) : \"\";\n}\nexport function resolvePath(base, path, from) {\n    if (hasSchemeRegex.test(path)) {\n        return undefined;\n    }\n    const basePath = normalize(base);\n    const fromPath = from && normalize(from);\n    let result = \"\";\n    if (!fromPath || path.charAt(0) === \"/\") {\n        result = basePath;\n    }\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n        result = basePath + fromPath;\n    }\n    else {\n        result = fromPath;\n    }\n    return result + normalize(path) || \"/\";\n}\nexport function invariant(value, message) {\n    if (value == null) {\n        throw new Error(message);\n    }\n    return value;\n}\nexport function joinPaths(from, to) {\n    const t = normalize(to);\n    if (t) {\n        const f = from.replace(/^\\/+|\\/*(\\*.*)?$/g, \"\");\n        return f ? `/${f}${t}` : t;\n    }\n    return normalize(from);\n}\nexport function extractSearchParams(url) {\n    const params = {};\n    url.searchParams.forEach((value, key) => {\n        params[key] = value;\n    });\n    return params;\n}\nexport function createMatcher(path, partial) {\n    const [pattern, splat] = path.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    const len = segments.length;\n    return (location) => {\n        const locSegments = location.split(\"/\").filter(Boolean);\n        const lenDiff = locSegments.length - len;\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n            return null;\n        }\n        const match = {\n            path: len ? \"\" : \"/\",\n            params: {}\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments[i];\n            const locSegment = locSegments[i];\n            if (segment[0] === \":\") {\n                match.params[segment.slice(1)] = locSegment;\n            }\n            else if (segment.localeCompare(locSegment, undefined, { sensitivity: \"base\" }) !== 0) {\n                return null;\n            }\n            match.path += `/${locSegment}`;\n        }\n        if (splat) {\n            match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n        }\n        return match;\n    };\n}\nexport function scoreRoute(route) {\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMemoObject(fn) {\n    const map = new Map();\n    const owner = getOwner();\n    return new Proxy({}, {\n        get(_, property) {\n            if (!map.has(property)) {\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n            }\n            return map.get(property)();\n        },\n        getOwnPropertyDescriptor() {\n            return {\n                enumerable: true,\n                configurable: true\n            };\n        },\n        ownKeys() {\n            return Reflect.ownKeys(fn());\n        }\n    });\n}\nexport function mergeSearchString(search, params) {\n    const merged = new URLSearchParams(search);\n    Object.entries(params).forEach(([key, value]) => {\n        if (value == null || value === \"\") {\n            merged.delete(key);\n        }\n        else {\n            merged.set(key, String(value));\n        }\n    });\n    return merged.toString();\n}\n","import { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, untrack, useContext, useTransition } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { normalizeIntegration } from \"./integration\";\nimport { createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString } from \"./utils\";\nconst MAX_REDIRECTS = 100;\nexport const RouterContextObj = createContext();\nexport const RouteContextObj = createContext();\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\nexport const useRoute = () => useContext(RouteContextObj) || useRouter().base;\nexport const useResolvedPath = (path) => {\n    const route = useRoute();\n    return createMemo(() => route.resolvePath(path()));\n};\nexport const useHref = (to) => {\n    const router = useRouter();\n    return createMemo(() => {\n        const to_ = to();\n        return to_ !== undefined ? router.renderPath(to_) : to_;\n    });\n};\nexport const useNavigate = () => useRouter().navigatorFactory();\nexport const useLocation = () => useRouter().location;\nexport const useIsRouting = () => useRouter().isRouting;\nexport const useMatch = (path) => {\n    const location = useLocation();\n    const matcher = createMemo(() => createMatcher(path()));\n    return createMemo(() => matcher()(location.pathname));\n};\nexport const useParams = () => useRoute().params;\nexport const useSearchParams = () => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const setSearchParams = (params, options) => {\n        const searchString = mergeSearchString(location.search, params);\n        navigate(searchString ? `?${searchString}` : \"\", { scroll: false, ...options, resolve: true });\n    };\n    return [location.query, setSearchParams];\n};\nexport const useData = (delta = 0) => {\n    let current = useRoute();\n    let n = delta;\n    while (n-- > 0) {\n        if (!current.parent) {\n            throw new RangeError(`Route ancestor ${delta} is out of bounds`);\n        }\n        current = current.parent;\n    }\n    return current.data;\n};\nexport function createRoute(routeDef, base = \"\", fallback) {\n    const { path: originalPath, component, data, children } = routeDef;\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\n    const path = joinPaths(base, originalPath);\n    const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n    return {\n        originalPath,\n        pattern,\n        element: component\n            ? () => createComponent(component, {})\n            : () => {\n                const { element } = routeDef;\n                return element === undefined && fallback\n                    ? createComponent(fallback, {})\n                    : element;\n            },\n        preload: routeDef.component\n            ? component.preload\n            : routeDef.preload,\n        data,\n        matcher: createMatcher(pattern, !isLeaf)\n    };\n}\nexport function createBranch(routes, index = 0) {\n    return {\n        routes,\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n        matcher(location) {\n            const matches = [];\n            for (let i = routes.length - 1; i >= 0; i--) {\n                const route = routes[i];\n                const match = route.matcher(location);\n                if (!match) {\n                    return null;\n                }\n                matches.unshift({\n                    ...match,\n                    route\n                });\n            }\n            return matches;\n        }\n    };\n}\nexport function createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\n    const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\n        const def = routeDefs[i];\n        if (def && typeof def === 'object' && def.hasOwnProperty('path')) {\n            const route = createRoute(def, base, fallback);\n            stack.push(route);\n            if (def.children) {\n                createBranches(def.children, route.pattern, fallback, stack, branches);\n            }\n            else {\n                const branch = createBranch([...stack], branches.length);\n                branches.push(branch);\n            }\n            stack.pop();\n        }\n    }\n    // Stack will be empty on final return\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nexport function getRouteMatches(branches, location) {\n    for (let i = 0, len = branches.length; i < len; i++) {\n        const match = branches[i].matcher(location);\n        if (match) {\n            return match;\n        }\n    }\n    return [];\n}\nexport function createLocation(path, state) {\n    const origin = new URL(\"http://sar\");\n    const url = createMemo(prev => {\n        const path_ = path();\n        try {\n            return new URL(path_, origin);\n        }\n        catch (err) {\n            console.error(`Invalid path ${path_}`);\n            return prev;\n        }\n    }, origin, {\n        equals: (a, b) => a.href === b.href\n    });\n    const pathname = createMemo(() => url().pathname);\n    const search = createMemo(() => url().search.slice(1));\n    const hash = createMemo(() => url().hash.slice(1));\n    const key = createMemo(() => \"\");\n    return {\n        get pathname() {\n            return pathname();\n        },\n        get search() {\n            return search();\n        },\n        get hash() {\n            return hash();\n        },\n        get state() {\n            return state();\n        },\n        get key() {\n            return key();\n        },\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\n    };\n}\nexport function createRouterContext(integration, base = \"\", data, out) {\n    const { signal: [source, setSource], utils = {} } = normalizeIntegration(integration);\n    const basePath = resolvePath(\"\", base);\n    const output = isServer && out\n        ? Object.assign(out, {\n            matches: [],\n            url: undefined\n        })\n        : undefined;\n    if (basePath === undefined) {\n        throw new Error(`${basePath} is not a valid base path`);\n    }\n    else if (basePath && !source().value) {\n        setSource({ value: basePath, replace: true, scroll: false });\n    }\n    const [isRouting, start] = useTransition();\n    const [reference, setReference] = createSignal(source().value);\n    const [state, setState] = createSignal(source().state);\n    const location = createLocation(reference, state);\n    const referrers = [];\n    const baseRoute = {\n        pattern: basePath,\n        params: {},\n        path: () => basePath,\n        outlet: () => null,\n        resolvePath(to) {\n            return resolvePath(basePath, to);\n        }\n    };\n    if (data) {\n        baseRoute.data = data({ params: {}, location, navigate: navigatorFactory(baseRoute) });\n    }\n    function navigateFromRoute(route, to, options) {\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n        untrack(() => {\n            if (typeof to === \"number\") {\n                if (!to) {\n                    // A delta of 0 means stay at the current location, so it is ignored\n                }\n                else if (utils.go) {\n                    utils.go(to);\n                }\n                else {\n                    console.warn(\"Router integration does not support relative routing\");\n                }\n                return;\n            }\n            const { replace, resolve, scroll, state: nextState } = {\n                replace: false,\n                resolve: true,\n                scroll: true,\n                ...options\n            };\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\n            if (resolvedTo === undefined) {\n                throw new Error(`Path '${to}' is not a routable path`);\n            }\n            else if (referrers.length >= MAX_REDIRECTS) {\n                throw new Error(\"Too many redirects\");\n            }\n            const current = reference();\n            if (resolvedTo !== current || nextState !== state()) {\n                if (isServer) {\n                    if (output) {\n                        output.url = resolvedTo;\n                    }\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\n                }\n                else {\n                    const len = referrers.push({ value: current, replace, scroll, state });\n                    start(() => {\n                        setReference(resolvedTo);\n                        setState(nextState);\n                    }).then(() => {\n                        if (referrers.length === len) {\n                            navigateEnd({\n                                value: resolvedTo,\n                                state: nextState\n                            });\n                        }\n                    });\n                }\n            }\n        });\n    }\n    function navigatorFactory(route) {\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n        route = route || useContext(RouteContextObj) || baseRoute;\n        return (to, options) => navigateFromRoute(route, to, options);\n    }\n    function navigateEnd(next) {\n        const first = referrers[0];\n        if (first) {\n            if (next.value !== first.value || next.state !== first.state) {\n                setSource({\n                    ...next,\n                    replace: first.replace,\n                    scroll: first.scroll\n                });\n            }\n            referrers.length = 0;\n        }\n    }\n    createRenderEffect(() => {\n        const { value, state } = source();\n        if (value !== untrack(reference)) {\n            start(() => {\n                setReference(value);\n                setState(state);\n            });\n        }\n    });\n    return {\n        base: baseRoute,\n        out: output,\n        location,\n        isRouting,\n        renderPath: utils.renderPath || ((path) => path),\n        navigatorFactory\n    };\n}\nexport function createRouteContext(router, parent, child, match) {\n    const { base, location, navigatorFactory } = router;\n    const { pattern, element: outlet, preload, data } = match().route;\n    const path = createMemo(() => match().path);\n    const params = createMemoObject(() => match().params);\n    preload && preload();\n    const route = {\n        parent,\n        pattern,\n        get child() {\n            return child();\n        },\n        path,\n        params,\n        outlet,\n        resolvePath(to) {\n            return resolvePath(base.path(), to, path());\n        }\n    };\n    if (data) {\n        route.data = data({ params, location, navigate: navigatorFactory(route) });\n    }\n    return route;\n}\n","/*@refresh skip*/\nimport { createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths } from \"./utils\";\nexport const Router = (props) => {\n    const { source, url, base, data, out } = props;\n    const integration = source || (isServer ? staticIntegration({ value: url || \"\" }) : pathIntegration());\n    const routerState = createRouterContext(integration, base, data, out);\n    return (<RouterContextObj.Provider value={routerState}>{props.children}</RouterContextObj.Provider>);\n};\nexport const Routes = (props) => {\n    const router = useRouter();\n    const parentRoute = useRoute();\n    const branches = createMemo(() => createBranches(props.children, joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n    const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n    if (router.out) {\n        router.out.matches.push(matches().map(({ route, path, params }) => ({\n            originalPath: route.originalPath,\n            pattern: route.pattern,\n            path,\n            params\n        })));\n    }\n    const disposers = [];\n    let root;\n    const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n        let equal = prevMatches && nextMatches.length === prevMatches.length;\n        const next = [];\n        for (let i = 0, len = nextMatches.length; i < len; i++) {\n            const prevMatch = prevMatches && prevMatches[i];\n            const nextMatch = nextMatches[i];\n            if (prev && prevMatch && nextMatch.route.pattern === prevMatch.route.pattern) {\n                next[i] = prev[i];\n            }\n            else {\n                equal = false;\n                if (disposers[i]) {\n                    disposers[i]();\n                }\n                createRoot(dispose => {\n                    disposers[i] = dispose;\n                    next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i]);\n                });\n            }\n        }\n        disposers.splice(nextMatches.length).forEach(dispose => dispose());\n        if (prev && equal) {\n            return prev;\n        }\n        root = next[0];\n        return next;\n    }));\n    return (<Show when={routeStates() && root}>\n      {route => <RouteContextObj.Provider value={route}>{route.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport const useRoutes = (routes, base) => {\n    return () => <Routes base={base}>{routes}</Routes>;\n};\nexport const Route = (props) => props;\nexport const Outlet = () => {\n    const route = useRoute();\n    return (<Show when={route.child}>\n      {child => <RouteContextObj.Provider value={child}>{child.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nfunction LinkBase(props) {\n    const [, rest] = splitProps(props, [\"children\", \"to\", \"href\", \"state\", \"onClick\"]);\n    const navigate = useNavigate();\n    const href = useHref(() => props.to);\n    const handleClick = evt => {\n        const { onClick, to, target } = props;\n        if (typeof onClick === \"function\") {\n            onClick(evt);\n        }\n        else if (onClick) {\n            onClick[0](onClick[1], evt);\n        }\n        if (to !== undefined &&\n            !evt.defaultPrevented &&\n            evt.button === 0 &&\n            (!target || target === \"_self\") &&\n            !(evt.metaKey || evt.altKey || evt.ctrlKey || evt.shiftKey)) {\n            evt.preventDefault();\n            navigate(to, {\n                resolve: false,\n                replace: props.replace || false,\n                scroll: !props.noScroll,\n                state: props.state\n            });\n        }\n    };\n    return (<a {...rest} href={href() || props.href} onClick={handleClick}>\n      {props.children}\n    </a>);\n}\nexport function Link(props) {\n    const to = useResolvedPath(() => props.href);\n    return <LinkBase {...props} to={to()}/>;\n}\nexport function NavLink(props) {\n    props = mergeProps({ activeClass: \"active\" }, props);\n    const [, rest] = splitProps(props, [\"activeClass\", \"end\"]);\n    const location = useLocation();\n    const to = useResolvedPath(() => props.href);\n    const isActive = createMemo(() => {\n        const to_ = to();\n        if (to_ === undefined) {\n            return false;\n        }\n        const path = to_.split(/[?#]/, 1)[0].toLowerCase();\n        const loc = location.pathname.toLowerCase();\n        return props.end ? path === loc : loc.startsWith(path);\n    });\n    return (<LinkBase {...rest} to={to()} classList={{ [props.activeClass]: isActive() }} aria-current={isActive() ? \"page\" : undefined}/>);\n}\nexport function Navigate(props) {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { href, state } = props;\n    const path = typeof href === \"function\" ? href({ navigate, location }) : href;\n    navigate(path, { replace: true, state });\n    return null;\n}\n","/*\n  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace\n  so it's better encapsulated. Now you can have multiple random number generators\n  and they won't stomp all over eachother's state.\n\n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n\n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n\n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_seed(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n\tif (seed == undefined) {\n\t\tseed = new Date().getTime();\n\t}\n\n\t/* Period parameters */\n\tthis.N = 624;\n\tthis.M = 397;\n\tthis.MATRIX_A = 0x9908b0df;   /* constant vector a */\n\tthis.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n\tthis.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n\n\tthis.mt = new Array(this.N); /* the array for the state vector */\n\tthis.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n\tif (seed.constructor == Array) {\n\t\tthis.init_by_array(seed, seed.length);\n\t}\n\telse {\n\t\tthis.init_seed(seed);\n\t}\n}\n\n/* initializes mt[N] with a seed */\n/* origin name init_genrand */\nMersenneTwister.prototype.init_seed = function(s) {\n\tthis.mt[0] = s >>> 0;\n\tfor (this.mti=1; this.mti<this.N; this.mti++) {\n\t\tvar s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n\t\tthis.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n\t\t+ this.mti;\n\t\t/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n\t\t/* In the previous versions, MSBs of the seed affect   */\n\t\t/* only MSBs of the array mt[].                        */\n\t\t/* 2002/01/09 modified by Makoto Matsumoto             */\n\t\tthis.mt[this.mti] >>>= 0;\n\t\t/* for >32 bit machines */\n\t}\n}\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n\tvar i, j, k;\n\tthis.init_seed(19650218);\n\ti=1; j=0;\n\tk = (this.N>key_length ? this.N : key_length);\n\tfor (; k; k--) {\n\t\tvar s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n\t\tthis.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n\t\t+ init_key[j] + j; /* non linear */\n\t\tthis.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n\t\ti++; j++;\n\t\tif (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n\t\tif (j>=key_length) j=0;\n\t}\n\tfor (k=this.N-1; k; k--) {\n\t\tvar s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n\t\tthis.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n\t\t- i; /* non linear */\n\t\tthis.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n\t\ti++;\n\t\tif (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n\t}\n\n\tthis.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n}\n\n/* generates a random number on [0,0xffffffff]-interval */\n/* origin name genrand_int32 */\nMersenneTwister.prototype.random_int = function() {\n\tvar y;\n\tvar mag01 = new Array(0x0, this.MATRIX_A);\n\t/* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n\tif (this.mti >= this.N) { /* generate N words at one time */\n\t\tvar kk;\n\n\t\tif (this.mti == this.N+1)  /* if init_seed() has not been called, */\n\t\t\tthis.init_seed(5489);  /* a default initial seed is used */\n\n\t\tfor (kk=0;kk<this.N-this.M;kk++) {\n\t\t\ty = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n\t\t\tthis.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n\t\t}\n\t\tfor (;kk<this.N-1;kk++) {\n\t\t\ty = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n\t\t\tthis.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n\t\t}\n\t\ty = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n\t\tthis.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n\t\tthis.mti = 0;\n\t}\n\n\ty = this.mt[this.mti++];\n\n\t/* Tempering */\n\ty ^= (y >>> 11);\n\ty ^= (y << 7) & 0x9d2c5680;\n\ty ^= (y << 15) & 0xefc60000;\n\ty ^= (y >>> 18);\n\n\treturn y >>> 0;\n}\n\n/* generates a random number on [0,0x7fffffff]-interval */\n/* origin name genrand_int31 */\nMersenneTwister.prototype.random_int31 = function() {\n\treturn (this.random_int()>>>1);\n}\n\n/* generates a random number on [0,1]-real-interval */\n/* origin name genrand_real1 */\nMersenneTwister.prototype.random_incl = function() {\n\treturn this.random_int()*(1.0/4294967295.0);\n\t/* divided by 2^32-1 */\n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n\treturn this.random_int()*(1.0/4294967296.0);\n\t/* divided by 2^32 */\n}\n\n/* generates a random number on (0,1)-real-interval */\n/* origin name genrand_real3 */\nMersenneTwister.prototype.random_excl = function() {\n\treturn (this.random_int() + 0.5)*(1.0/4294967296.0);\n\t/* divided by 2^32 */\n}\n\n/* generates a random number on [0,1) with 53-bit resolution*/\n/* origin name genrand_res53 */\nMersenneTwister.prototype.random_long = function() {\n\tvar a=this.random_int()>>>5, b=this.random_int()>>>6;\n\treturn(a*67108864.0+b)*(1.0/9007199254740992.0);\n}\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\nmodule.exports = MersenneTwister;\n","import { $PROXY, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !obj.__proto__ || obj.__proto__ === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction ownKeys(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode() {\n  const [s, set] = createSignal(undefined, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n    return wrappable ? wrap$1(value) : value;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const array = Array.isArray(state);\n  const len = state.length;\n  const isUndefined = value === undefined;\n  const notify = array || isUndefined === property in state;\n  if (isUndefined) {\n    delete state[property];\n  } else state[property] = value;\n  let nodes = getDataNodes(state),\n      node;\n  (node = nodes[property]) && node.$();\n  if (array && state.length !== len) (node = nodes.length) && node.$();\n  notify && (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n      prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(store, options) {\n  const unwrappedStore = unwrap(store || {});\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => updatePath(unwrappedStore, args));\n  }\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n    return wrappable ? wrap(value) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\n\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    target !== previous && setProperty(parent, property, target);\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n            newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    applyState(v, {\n      state\n    }, \"state\", merge, key);\n    return state;\n  };\n}\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    return isWrappable(value) ? new Proxy(value, setterTraps) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) fn(new Proxy(state, setterTraps));\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, produce, reconcile, unwrap };\n","(function(a,b){if(\"function\"==typeof define&&define.amd)define([],b);else if(\"undefined\"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,\"undefined\"!=typeof module&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map","function userAgent(pattern) {\n    // @ts-ignore\n    if (typeof window !== \"undefined\" && window.navigator) {\n        return !!( /*@__PURE__*/navigator.userAgent.match(pattern));\n    }\n}\nconst iOS = userAgent(/iP(ad|od|hone)/i);\nconst iOS13 = typeof window !== \"undefined\"\n    ? iOS && \"download\" in document.createElement(\"a\")\n    : null;\nif (iOS && !iOS13) {\n    const html = document.querySelector(\"html\");\n    html.style.cursor = \"pointer\";\n    // @ts-ignore\n    html.style.webkitTapHighlightColor = \"rgba(0, 0, 0, 0)\";\n}\n","export const dismissStack = [];\nexport const addDismissStack = (props) => {\n    dismissStack.push(props);\n};\nexport const removeDismissStack = (id) => {\n    const foundIdx = dismissStack.findIndex((item) => item.uniqueId === id);\n    if (foundIdx === -1)\n        return;\n    const foundStack = dismissStack[foundIdx];\n    dismissStack.splice(foundIdx, 1);\n    return foundStack;\n};\n","const _tabbableSelectors = [\n    \"a[href]\",\n    \"area[href]\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"button:not([disabled])\",\n    \"iframe\",\n    \"[tabindex]\",\n    \"[contentEditable=true]\",\n].reduce((a, c, idx) => `${a}${idx ? \",\" : \"\"}${c}:not([tabindex=\"-1\"])`, \"\");\nexport const getNextTabbableElement = ({ from = document.activeElement, stopAtElement, ignoreElement = [], allowSelectors, direction = \"forwards\", }) => {\n    const parent = from.parentElement;\n    const visitedElement = from;\n    const tabbableSelectors = _tabbableSelectors + (allowSelectors ? \",\" + allowSelectors.join(\",\") : \"\");\n    if (!visitedElement)\n        return null;\n    const isHidden = (el, contentWindow = window) => {\n        const checkByStyle = (style) => style.display === \"none\" || style.visibility === \"hidden\";\n        if ((el.style && checkByStyle(el.style)) || el.hidden)\n            return true;\n        const style = contentWindow.getComputedStyle(el);\n        if (!style || checkByStyle(style))\n            return true;\n        return false;\n    };\n    const checkHiddenAncestors = (target, parent, contentWindow) => {\n        const ancestors = [];\n        let node = target;\n        if (isHidden(node))\n            return true;\n        while (true) {\n            node = node.parentElement;\n            if (!node || node === parent) {\n                break;\n            }\n            ancestors.push(node);\n        }\n        for (const node of ancestors) {\n            if (isHidden(node, contentWindow)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const checkChildren = (children, parent, reverse, contentWindow) => {\n        const length = children.length;\n        if (length && isHidden(parent))\n            return null;\n        if (reverse) {\n            for (let i = length - 1; i > -1; i--) {\n                const child = children[i];\n                if (ignoreElement.some((el) => el.contains(child)))\n                    continue;\n                if (!checkHiddenAncestors(child, parent, contentWindow)) {\n                    if (child.tagName === \"IFRAME\") {\n                        const iframeChild = queryIframe(child, reverse);\n                        if (iframeChild)\n                            return iframeChild;\n                    }\n                    return child;\n                }\n            }\n            return null;\n        }\n        for (let i = 0; i < length; i++) {\n            const child = children[i];\n            if (ignoreElement.some((el) => el.contains(child)))\n                continue;\n            if (!checkHiddenAncestors(child, parent, contentWindow)) {\n                if (child.tagName === \"IFRAME\") {\n                    const iframeChild = queryIframe(child);\n                    if (iframeChild)\n                        return iframeChild;\n                }\n                return child;\n            }\n        }\n        return null;\n    };\n    const getIframeWindow = (iframe) => {\n        try {\n            return iframe.contentWindow;\n        }\n        catch (e) {\n            return null;\n        }\n    };\n    const queryIframe = (el, inverseQuery) => {\n        if (!el)\n            return null;\n        if (el.tagName !== \"IFRAME\")\n            return el;\n        const iframeWindow = getIframeWindow(el);\n        const iframeDocument = iframeWindow.document;\n        if (!iframeWindow)\n            return el;\n        const tabindex = el.getAttribute(\"tabindex\");\n        if (tabindex)\n            return el;\n        const els = iframeDocument.querySelectorAll(tabbableSelectors);\n        const result = checkChildren(els, iframeDocument.documentElement, inverseQuery, iframeWindow);\n        return queryIframe(result);\n    };\n    const traverseNextSiblingsThenUp = (parent, visitedElement) => {\n        let hasPassedVisitedElement = false;\n        const children = parent.children;\n        const childrenCount = children.length;\n        if (direction === \"forwards\") {\n            for (let i = 0; i < childrenCount; i++) {\n                const child = children[i];\n                if (hasPassedVisitedElement) {\n                    if (ignoreElement.some((el) => el === child))\n                        continue;\n                    if (child.matches(tabbableSelectors)) {\n                        if (isHidden(child))\n                            continue;\n                        const el = queryIframe(child);\n                        if (el)\n                            return el;\n                        return child;\n                    }\n                    const els = child.querySelectorAll(tabbableSelectors);\n                    const el = checkChildren(els, child);\n                    if (el) {\n                        return el;\n                    }\n                    continue;\n                }\n                if (child === stopAtElement) {\n                    return null;\n                }\n                if (child === visitedElement) {\n                    hasPassedVisitedElement = true;\n                    continue;\n                }\n            }\n        }\n        else {\n            for (let i = childrenCount - 1; i >= 0; i--) {\n                const child = children[i];\n                if (hasPassedVisitedElement) {\n                    if (ignoreElement.some((el) => el === child))\n                        continue;\n                    if (child.matches(tabbableSelectors)) {\n                        if (isHidden(child))\n                            continue;\n                        const el = queryIframe(child);\n                        if (el)\n                            return el;\n                        return child;\n                    }\n                    const els = child.querySelectorAll(tabbableSelectors);\n                    const el = checkChildren(els, child, true);\n                    if (el)\n                        return el;\n                    continue;\n                }\n                if (child === stopAtElement) {\n                    return null;\n                }\n                if (child === visitedElement) {\n                    hasPassedVisitedElement = true;\n                    continue;\n                }\n            }\n        }\n        visitedElement = parent;\n        parent = parent.parentElement;\n        if (!parent)\n            return null;\n        return traverseNextSiblingsThenUp(parent, visitedElement);\n    };\n    const result = traverseNextSiblingsThenUp(parent, visitedElement);\n    return result;\n};\n","import { dismissStack } from \"./dismissStack\";\nimport { getMenuButton, markFocusedMenuButton } from \"../local/menuButton\";\nimport { checkThenClose, queryElement } from \"../utils\";\nimport { getNextTabbableElement } from \"../utils/tabbing\";\nlet scrollEventAddedViaTouch = false;\nlet scrollEventAdded = false;\nlet pollTimeoutId = null;\nlet timestampOfTabkey = 0;\nlet cachedScrollTarget = null;\nlet cachedPolledElement = null;\nexport const globalState = {\n    closeByFocusSentinel: false,\n    closedBySetOpen: false,\n    addedDocumentClick: false,\n    documentClickTimeout: null,\n    closedByEvents: false,\n    focusedMenuBtns: new Set(),\n};\nexport const onDocumentClick = (e) => {\n    const target = e.target;\n    checkThenClose(dismissStack, (item) => {\n        if (item.overlay ||\n            item.overlayElement ||\n            getMenuButton(item.menuBtnEls).contains(target) ||\n            item.containerEl.contains(target))\n            return;\n        return item;\n    }, (item) => {\n        const { setOpen } = item;\n        globalState.closedByEvents = true;\n        setOpen(false);\n    });\n    globalState.addedDocumentClick = false;\n};\nexport const onWindowBlur = (e) => {\n    const item = dismissStack[dismissStack.length - 1];\n    // menuPopup item was the last tabbable item in the document and current focused item is outside of document, such as browser URL bar, then menuPopup/stacks will close\n    setTimeout(() => {\n        const difference = e.timeStamp - timestampOfTabkey;\n        if (!document.hasFocus()) {\n            if (difference < 50) {\n                checkThenClose(dismissStack, (item) => item, (item) => {\n                    const { setOpen } = item;\n                    globalState.closedByEvents = true;\n                    setOpen(false);\n                });\n                return;\n            }\n        }\n    });\n    const onBlurWindow = (item) => {\n        if (item.overlay || item.overlayEl)\n            return;\n        if (!item.closeWhenDocumentBlurs)\n            return;\n        const menuBtnEl = getMenuButton(item.menuBtnEls);\n        menuBtnEl.focus();\n        globalState.closedByEvents = true;\n        item.setOpen(false);\n    };\n    if (item.overlay)\n        return;\n    setTimeout(() => {\n        const activeElement = document.activeElement;\n        if (!activeElement || activeElement.tagName !== \"IFRAME\") {\n            checkThenClose(dismissStack, (item) => item, (item) => onBlurWindow(item));\n            return;\n        }\n        checkThenClose(dismissStack, (item) => {\n            const { containerEl } = item;\n            if (containerEl.contains(activeElement)) {\n                cachedPolledElement = activeElement;\n                pollingIframe();\n                document.addEventListener(\"visibilitychange\", onVisibilityChange);\n                return;\n            }\n            return item;\n        }, (item) => {\n            const { setOpen } = item;\n            globalState.closedByEvents = true;\n            setOpen(false);\n        });\n    });\n};\nexport const onKeyDown = (e) => {\n    const { focusedMenuBtn, setOpen, menuBtnEls, cursorKeys, closeWhenEscapeKeyIsPressed, focusElementOnClose, timeouts, } = dismissStack[dismissStack.length - 1];\n    if (e.key === \"Tab\") {\n        timestampOfTabkey = e.timeStamp;\n    }\n    if (cursorKeys) {\n        onCursorKeys(e);\n    }\n    if (e.key !== \"Escape\" || !closeWhenEscapeKeyIsPressed)\n        return;\n    const menuBtnEl = getMenuButton(menuBtnEls);\n    const el = queryElement({}, {\n        inputElement: focusElementOnClose,\n        type: \"focusElementOnClose\",\n        subType: \"escapeKey\",\n    }) || menuBtnEl;\n    if (el) {\n        el.focus();\n        if (el === menuBtnEl) {\n            markFocusedMenuButton({ focusedMenuBtn, timeouts, el });\n        }\n    }\n    globalState.closedByEvents = true;\n    setOpen(false);\n};\nexport const onScrollClose = (e) => {\n    const target = e.target;\n    if (cachedScrollTarget === target)\n        return;\n    checkThenClose(dismissStack, (item) => {\n        const { menuPopupEl } = item;\n        if (menuPopupEl.contains(target)) {\n            cachedScrollTarget = target;\n            return null;\n        }\n        return item;\n    }, (item) => {\n        const { setOpen, focusElementOnClose, menuBtnEls } = item;\n        const menuBtnEl = getMenuButton(menuBtnEls);\n        globalState.closedByEvents = true;\n        setOpen(false);\n        const el = queryElement({}, {\n            inputElement: focusElementOnClose,\n            type: \"focusElementOnClose\",\n            subType: \"scrolling\",\n        }) || menuBtnEl;\n        if (el) {\n            el.focus();\n        }\n    });\n};\nexport const addGlobalEvents = (closeWhenScrolling) => {\n    cachedScrollTarget = null;\n    if (!scrollEventAdded && closeWhenScrolling) {\n        scrollEventAdded = false;\n        window.addEventListener(\"wheel\", onScrollClose, {\n            capture: true,\n            passive: true,\n        });\n        document.body.addEventListener(\"touchmove\", onTouchMove);\n    }\n    if (dismissStack.length)\n        return;\n    document.addEventListener(\"keydown\", onKeyDown);\n    window.addEventListener(\"blur\", onWindowBlur);\n};\nexport const removeGlobalEvents = () => {\n    if (dismissStack.length)\n        return;\n    scrollEventAdded = false;\n    globalState.addedDocumentClick = false;\n    // globalState.menuBtnEl = null;\n    window.clearTimeout(globalState.documentClickTimeout);\n    globalState.documentClickTimeout = null;\n    document.removeEventListener(\"keydown\", onKeyDown);\n    document.removeEventListener(\"click\", onDocumentClick);\n    window.removeEventListener(\"blur\", onWindowBlur);\n    window.removeEventListener(\"wheel\", onScrollClose, {\n        capture: true,\n    });\n    document.body.removeEventListener(\"touchmove\", onTouchMove);\n};\nconst onTouchMove = () => {\n    if (scrollEventAddedViaTouch)\n        return;\n    scrollEventAddedViaTouch = true;\n    document.body.addEventListener(\"touchend\", () => {\n        scrollEventAddedViaTouch = false;\n    }, { once: true });\n    window.addEventListener(\"scroll\", onScrollClose, {\n        capture: true,\n        passive: true,\n        once: true,\n    });\n};\nconst onCursorKeys = (e) => {\n    const keys = [\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\"];\n    const horizontalKeys = [\"ArrowLeft\", \"ArrowRight\"];\n    if (!keys.includes(e.key))\n        return;\n    e.preventDefault();\n    if (horizontalKeys.includes(e.key))\n        return;\n    const { menuBtnEls, menuPopupEl, containerEl, focusSentinelBeforeEl } = dismissStack[dismissStack.length - 1];\n    const menuBtnEl = getMenuButton(menuBtnEls);\n    let activeElement = document.activeElement;\n    let direction;\n    if (e.key === \"ArrowDown\") {\n        direction = \"forwards\";\n    }\n    else {\n        direction = \"backwards\";\n    }\n    if (activeElement === menuBtnEl ||\n        activeElement === menuPopupEl ||\n        activeElement === containerEl) {\n        direction = \"forwards\";\n        activeElement = focusSentinelBeforeEl;\n    }\n    const el = getNextTabbableElement({\n        from: activeElement,\n        direction,\n        stopAtElement: menuPopupEl,\n    });\n    if (el) {\n        el.focus();\n    }\n};\nconst onVisibilityChange = () => {\n    if (document.visibilityState === \"visible\" && pollTimeoutId != null) {\n        pollingIframe();\n        return;\n    }\n    clearTimeout(pollTimeoutId);\n};\n// polls iframe to deal with edge case if menuPopup item selected is an iframe and then select another iframe that is \"outside\" of menuPopup\nconst pollingIframe = () => {\n    // worst case scenerio is user has to wait for up to 250ms for menuPopup to close, while average case is 125ms\n    const duration = 250;\n    const poll = () => {\n        const activeElement = document.activeElement;\n        if (!activeElement) {\n            return;\n        }\n        if (cachedPolledElement === activeElement) {\n            pollTimeoutId = window.setTimeout(poll, duration);\n            return;\n        }\n        checkThenClose(dismissStack, (item) => {\n            const { containerEl } = item;\n            if (activeElement.tagName === \"IFRAME\") {\n                if (containerEl && !containerEl.contains(activeElement)) {\n                    return item;\n                }\n                cachedPolledElement = activeElement;\n                pollTimeoutId = window.setTimeout(poll, duration);\n            }\n            return;\n        }, (item) => {\n            const { setOpen } = item;\n            globalState.closedByEvents = true;\n            setOpen(false);\n            cachedPolledElement = null;\n            pollTimeoutId = null;\n            document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        });\n    };\n    pollTimeoutId = window.setTimeout(poll, duration);\n};\n","import { globalState } from \"../global/globalEvents\";\nexport const onFocusFromOutsideAppOrTab = (state, e) => {\n    const { containerEl, setOpen, onClickDocumentRef } = state;\n    if (containerEl.contains(e.target))\n        return;\n    globalState.closedByEvents = true;\n    setOpen(false);\n    state.prevFocusedEl = null;\n    state.addedFocusOutAppEvents = false;\n    document.removeEventListener(\"click\", onClickDocumentRef);\n};\nexport const onClickDocument = (state, e) => {\n    const { containerEl, setOpen, onFocusFromOutsideAppOrTabRef } = state;\n    if (!containerEl)\n        return;\n    if (containerEl.contains(e.target)) {\n        state.addedFocusOutAppEvents = false;\n        if (state.prevFocusedEl) {\n            state.prevFocusedEl.removeEventListener(\"focus\", onFocusFromOutsideAppOrTabRef);\n        }\n        state.prevFocusedEl = null;\n        return;\n    }\n    if (state.prevFocusedEl) {\n        state.prevFocusedEl.removeEventListener(\"focus\", onFocusFromOutsideAppOrTabRef);\n    }\n    state.prevFocusedEl = null;\n    globalState.closedByEvents = true;\n    setOpen(false);\n    state.addedFocusOutAppEvents = false;\n};\nexport const removeOutsideFocusEvents = (state) => {\n    const { onFocusFromOutsideAppOrTabRef, onClickDocumentRef } = state;\n    if (!state.prevFocusedEl)\n        return;\n    state.prevFocusedEl.removeEventListener(\"focus\", onFocusFromOutsideAppOrTabRef);\n    document.removeEventListener(\"click\", onClickDocumentRef);\n    state.prevFocusedEl = null;\n    state.addedFocusOutAppEvents = false;\n};\n","import { dismissStack } from \"../global/dismissStack\";\nimport { globalState, onDocumentClick } from \"../global/globalEvents\";\nimport { removeOutsideFocusEvents } from \"./outside\";\nimport { checkThenClose, hasDisplayNone } from \"../utils\";\nimport { getNextTabbableElement } from \"../utils/tabbing\";\nlet mousedownFired = false;\nexport const onClickMenuButton = (state, e) => {\n    const { timeouts, closeWhenMenuButtonIsClicked, focusedMenuBtn, onClickOutsideMenuButtonRef: onClickOutsideRef, setOpen, open, } = state;\n    const menuBtnEl = e.currentTarget;\n    globalState.focusedMenuBtns.forEach((item) => (item.el = null));\n    document.removeEventListener(\"click\", onClickOutsideRef);\n    setTimeout(() => {\n        document.addEventListener(\"click\", onClickOutsideRef, { once: true });\n    });\n    // globalState.menuBtnEls.clear();\n    state.menuBtnKeyupTabFired = false;\n    if (mousedownFired && !open()) {\n        mousedownFired = false;\n        return;\n    }\n    mousedownFired = false;\n    globalState.addedDocumentClick = false;\n    document.removeEventListener(\"click\", onDocumentClick);\n    menuBtnEl.focus();\n    focusedMenuBtn.el = menuBtnEl;\n    globalState.focusedMenuBtns.add(focusedMenuBtn);\n    clearTimeout(timeouts.containerFocusTimeoutId);\n    clearTimeout(timeouts.menuButtonBlurTimeoutId);\n    timeouts.containerFocusTimeoutId = null;\n    // iOS triggers refocus i think...\n    if (!open()) {\n        menuBtnEl.addEventListener(\"focus\", state.onFocusMenuButtonRef, {\n            once: true,\n        });\n        menuBtnEl.addEventListener(\"keydown\", state.onKeydownMenuButtonRef);\n        menuBtnEl.addEventListener(\"blur\", state.onBlurMenuButtonRef);\n    }\n    else {\n        // if (closeWhenMenuButtonIsClicked) {\n        //   state.menuBtnEl!.removeEventListener(\"focus\", state.onFocusMenuButtonRef);\n        //   state.menuBtnEl!.removeEventListener(\n        //     \"keydown\",\n        //     state.onKeydownMenuButtonRef\n        //   );\n        //   state.menuBtnEl!.removeEventListener(\"blur\", state.onBlurMenuButtonRef);\n        // }\n    }\n    if (!closeWhenMenuButtonIsClicked) {\n        setOpen(true);\n        return;\n    }\n    if (open()) {\n        // focusedMenuBtn.el = null;\n        globalState.closedByEvents = true;\n    }\n    setOpen(!open());\n};\nexport const onBlurMenuButton = (state, e) => {\n    const { containerEl, focusedMenuBtn, overlay, setOpen, timeouts, closeWhenMenuButtonIsClicked, } = state;\n    if (state.menuBtnKeyupTabFired) {\n        state.menuBtnKeyupTabFired = false;\n        return;\n    }\n    if (mousedownFired && !closeWhenMenuButtonIsClicked) {\n        return;\n    }\n    if (!e.relatedTarget) {\n        if (!overlay) {\n            if (!globalState.addedDocumentClick) {\n                globalState.addedDocumentClick = true;\n                document.addEventListener(\"click\", onDocumentClick, { once: true });\n            }\n        }\n        return;\n    }\n    removeOutsideFocusEvents(state);\n    if (!containerEl)\n        return;\n    if (containerEl.contains(e.relatedTarget))\n        return;\n    const run = () => {\n        globalState.closedByEvents = true;\n        focusedMenuBtn.el = null;\n        setOpen(false);\n    };\n    timeouts.menuButtonBlurTimeoutId = window.setTimeout(run);\n};\n// When reclicking menuButton for closing intention, Safari will trigger blur upon mousedown, which the click event fires after. This results menuPopup close then reopen. This mousedown event prevents that bug.\nexport const onMouseDownMenuButton = (state, e) => {\n    const menuBtnEl = e.currentTarget;\n    if (!state.open()) {\n        checkThenClose(dismissStack, (item) => {\n            if (item.containerEl.contains(menuBtnEl))\n                return;\n            return item;\n        }, (item) => {\n            globalState.focusedMenuBtns.forEach((item) => (item.el = null));\n            globalState.closedByEvents = true;\n            item.setOpen(false);\n        });\n        mousedownFired = false;\n        return;\n    }\n    mousedownFired = true;\n};\nexport const onClickOutsideMenuButton = (state) => {\n    state.focusedMenuBtn.el = null;\n};\nexport const onKeydownMenuButton = (state, e) => {\n    const { containerEl, setOpen, open, onKeydownMenuButtonRef, onBlurMenuButtonRef, mount, focusSentinelBeforeEl, focusSentinelAfterEl, } = state;\n    const menuBtnEl = e.currentTarget;\n    if (e.key !== \"Tab\")\n        return;\n    globalState.focusedMenuBtns.forEach((item) => (item.el = null));\n    if (!open())\n        return;\n    state.menuBtnKeyupTabFired = true;\n    if (e.key === \"Tab\" && e.shiftKey) {\n        globalState.closedByEvents = true;\n        // menuPopup is previous general sibling of menuButton\n        if (!mount || menuBtnEl.nextElementSibling !== containerEl) {\n            e.preventDefault();\n            let el = getNextTabbableElement({\n                from: menuBtnEl,\n                direction: \"backwards\",\n                ignoreElement: [\n                    containerEl,\n                    focusSentinelBeforeEl,\n                    focusSentinelAfterEl,\n                ],\n            });\n            if (el) {\n                el.focus();\n            }\n        }\n        setOpen(false);\n        menuBtnEl.removeEventListener(\"keydown\", onKeydownMenuButtonRef);\n        menuBtnEl.removeEventListener(\"blur\", onBlurMenuButtonRef);\n        return;\n    }\n    e.preventDefault();\n    let el = getNextTabbableElement({\n        from: focusSentinelBeforeEl,\n        stopAtElement: containerEl,\n    });\n    if (el) {\n        el.focus();\n    }\n    else {\n        containerEl.focus();\n    }\n    if (!el) {\n        setOpen(false);\n        el = getNextTabbableElement({\n            from: focusSentinelBeforeEl,\n        });\n        if (el) {\n            el.focus();\n        }\n    }\n    menuBtnEl.removeEventListener(\"keydown\", onKeydownMenuButtonRef);\n    menuBtnEl.removeEventListener(\"blur\", onBlurMenuButtonRef);\n};\nexport const onFocusMenuButton = (state) => {\n    const { closeWhenMenuButtonIsTabbed, timeouts } = state;\n    if (!closeWhenMenuButtonIsTabbed) {\n        clearTimeout(timeouts.containerFocusTimeoutId);\n    }\n};\nexport const getMenuButton = (menuBtnEls) => {\n    if (menuBtnEls.length <= 1)\n        return menuBtnEls[0];\n    return menuBtnEls.find((menuBtnEl) => {\n        if (!menuBtnEl || hasDisplayNone(menuBtnEl))\n            return;\n        return menuBtnEl;\n    });\n};\nexport const markFocusedMenuButton = ({ focusedMenuBtn, timeouts, el, }) => {\n    focusedMenuBtn.el = el;\n    el.addEventListener(\"blur\", (e) => {\n        const el = e.currentTarget;\n        globalState.focusedMenuBtns.add(focusedMenuBtn);\n        setTimeout(() => {\n            if (!el.isConnected)\n                return;\n            focusedMenuBtn.el = null;\n        });\n    }, {\n        once: true,\n    });\n};\nexport const removeMenuButtonEvents = (state, onCleanup) => {\n    if (!state || !state.menuBtnEls)\n        return;\n    state.menuBtnEls.forEach((menuBtnEl) => {\n        menuBtnEl.removeEventListener(\"focus\", state.onFocusMenuButtonRef);\n        // menuBtnEl.removeEventListener(\"keydown\", state.onKeydownMenuButtonRef);\n        menuBtnEl.removeEventListener(\"blur\", state.onBlurMenuButtonRef);\n        if (onCleanup) {\n            menuBtnEl.removeEventListener(\"click\", state.onClickMenuButtonRef);\n            menuBtnEl.removeEventListener(\"mousedown\", state.onMouseDownMenuButtonRef);\n        }\n    });\n};\n","import { getMenuButton } from \"../local/menuButton\";\nimport { getNextTabbableElement } from \"./tabbing\";\n/**\n *  Iterate stack backwards, checks item, pass it close callback. First falsy value breaks iteration.\n */\nexport const checkThenClose = (arr, checkCb, destroyCb) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        const item = checkCb(arr[i]);\n        if (item) {\n            destroyCb(item);\n            continue;\n        }\n        return;\n    }\n};\nexport const findItemReverse = (arr, cb) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        const item = arr[i];\n        const foundItem = cb(item);\n        if (foundItem) {\n            return [item, i];\n        }\n    }\n    return [null, -1];\n};\nexport const parseValToNum = (value) => {\n    if (typeof value === \"string\") {\n        return Number(value.match(/(.+)(px|%)/)[1]);\n    }\n    return value || 0;\n};\nexport const camelize = (s) => s.replace(/-./g, (x) => x.toUpperCase()[1]);\nexport const matchByFirstChild = ({ parent, matchEl, }) => {\n    if (parent === matchEl)\n        return true;\n    const query = (el) => {\n        if (!el)\n            return false;\n        const child = el.children[0];\n        if (child === matchEl) {\n            return true;\n        }\n        return query(child);\n    };\n    return query(parent);\n};\nexport const queryElement = (state, { inputElement, type, subType, }) => {\n    if (inputElement === \"menuPopup\") {\n        return state.menuPopupEl;\n    }\n    if (inputElement === \"menuButton\") {\n        return getMenuButton(state.menuBtnEls);\n    }\n    if (type === \"focusElementOnOpen\") {\n        if (inputElement === \"firstChild\") {\n            return getNextTabbableElement({\n                from: state.focusSentinelBeforeEl,\n                stopAtElement: state.containerEl,\n            });\n        }\n        if (typeof inputElement === \"string\") {\n            return state.containerEl?.querySelector(inputElement);\n        }\n        if (inputElement instanceof Element) {\n            return inputElement;\n        }\n        return inputElement();\n    }\n    if (inputElement == null && type === \"menuPopup\") {\n        if (!state.containerEl)\n            return null;\n        if (state.menuPopupEl)\n            return state.menuPopupEl;\n        return state.containerEl.children[1];\n    }\n    if (typeof inputElement === \"string\" && type === \"menuButton\") {\n        return document.querySelector(inputElement);\n    }\n    if (typeof inputElement === \"string\") {\n        return document.querySelector(inputElement);\n    }\n    if (inputElement instanceof Element) {\n        return inputElement;\n    }\n    if (typeof inputElement === \"function\") {\n        const result = inputElement();\n        if (result instanceof Element) {\n            return result;\n        }\n        if (type === \"closeButton\") {\n            if (!state.containerEl)\n                return null;\n            return state.containerEl.querySelector(result);\n        }\n    }\n    if (type === \"focusElementOnClose\") {\n        if (!inputElement)\n            return null;\n        switch (subType) {\n            case \"tabForwards\":\n                return queryElement(state, { inputElement: inputElement.tabForwards });\n            case \"tabBackwards\":\n                return queryElement(state, { inputElement: inputElement.tabBackwards });\n            case \"click\":\n                return queryElement(state, { inputElement: inputElement.click });\n            case \"escapeKey\":\n                return queryElement(state, { inputElement: inputElement.escapeKey });\n            case \"scrolling\":\n                return queryElement(state, { inputElement: inputElement.scrolling });\n        }\n    }\n    if (inputElement == null)\n        return null;\n    if (Array.isArray(inputElement)) {\n        return inputElement.map((el) => queryElement(state, { inputElement: el, type }));\n    }\n    for (const key in inputElement) {\n        const item = inputElement[key];\n        return queryElement(state, { inputElement: item });\n    }\n    return null;\n};\n/**\n * Why this might be better than direct check of CSS display property? Because you do not need to check all parent elements. If some parent element has display: none, its children are hidden too but still has `element.style.display !== 'none'`\n */\nexport const hasDisplayNone = (el) => el.offsetHeight === 0 && el.offsetWidth === 0;\n","import { queryElement } from \"../utils\";\nexport const addMenuPopupEl = (state) => {\n    const { menuPopup } = state;\n    if (state.menuPopupAdded)\n        return;\n    state.menuPopupEl = queryElement(state, {\n        inputElement: menuPopup,\n        type: \"menuPopup\",\n    });\n    if (state.menuPopupEl) {\n        state.menuPopupAdded = true;\n        state.menuPopupEl.setAttribute(\"tabindex\", \"-1\");\n    }\n};\nexport const removeMenuPopupEl = (state) => {\n    if (!state.menuPopupEl)\n        return;\n    if (!state.menuPopupAdded)\n        return;\n    state.menuPopupEl = null;\n    state.menuPopupAdded = false;\n};\n","import { createSignal, sharedConfig } from \"solid-js\";\nimport { insert, isServer } from \"solid-js/web\";\nconst CreatePortal = (props) => {\n    if (isServer)\n        return \"\";\n    const { useShadow } = props, marker = props.marker || document.createTextNode(\"\"), mount = props.mount || document.body;\n    // don't render when hydrating\n    function renderPortal() {\n        if (sharedConfig.context) {\n            const [s, set] = createSignal(false);\n            queueMicrotask(() => set(true));\n            return () => s() && props.popupChildren;\n        }\n        else\n            return () => props.popupChildren;\n    }\n    const container = document.createElement(\"div\"), renderRoot = useShadow && container.attachShadow\n        ? container.attachShadow({ mode: \"open\" })\n        : container;\n    // if (!props.stopComponentEventPropagation) {\n    Object.defineProperty(container, \"host\", {\n        get() {\n            return marker.parentNode;\n        },\n    });\n    // }\n    insert(renderRoot, renderPortal());\n    // mount.appendChild(props.overlayChildren as HTMLElement);\n    const overlayChildren = props.overlayChildren;\n    if (overlayChildren) {\n        container.insertAdjacentElement(\"afterbegin\", overlayChildren);\n    }\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    if (props.onCreate != null) {\n        // @ts-ignore\n        props.onCreate(mount, container, marker);\n    }\n    return !props.stopComponentEventPropagation ? marker : null;\n};\nexport default CreatePortal;\n","import { untrack, createComputed, createSignal, children, } from \"solid-js\";\nimport { camelize, queryElement } from \"../utils\";\nexport const Transition = (props) => {\n    let el;\n    let first = true;\n    const [s1, set1] = createSignal();\n    const resolved = children(() => props.children);\n    const { onBeforeEnter, onEnter, onAfterEnter, onBeforeExit, onExit, onAfterExit, appendToElement, } = props;\n    function getClassState(type) {\n        const name = props.name || \"s\";\n        const propStr = camelize(type) + \"Class\";\n        // @ts-ignore\n        const classState = props[propStr];\n        return classState ? classState.split(\" \") : [`${name}-${type}`];\n    }\n    const getElement = (el) => {\n        if (appendToElement) {\n            if (appendToElement === \"menuPopup\") {\n                return queryElement({ containerEl: el }, { inputElement: null, type: \"menuPopup\" });\n            }\n            return typeof appendToElement === \"string\"\n                ? el.querySelector(appendToElement)\n                : appendToElement;\n        }\n        return el;\n    };\n    function enterTransition(_el, prev) {\n        const enterClasses = getClassState(\"enter\");\n        const enterActiveClasses = getClassState(\"enter-active\");\n        const enterToClasses = getClassState(\"enter-to\");\n        const el = getElement(_el);\n        onBeforeEnter && onBeforeEnter(el);\n        el.classList.add(...enterClasses);\n        el.classList.add(...enterActiveClasses);\n        requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n                el.classList.remove(...enterClasses);\n                el.classList.add(...enterToClasses);\n                onEnter && onEnter(el, endTransition);\n                if (!onEnter || onEnter.length < 2) {\n                    el.addEventListener(\"transitionend\", endTransition, { once: true });\n                    el.addEventListener(\"animationend\", endTransition, { once: true });\n                }\n            });\n        });\n        function endTransition() {\n            if (el) {\n                el.classList.remove(...enterActiveClasses);\n                el.classList.remove(...enterToClasses);\n                s1() !== _el && set1(_el);\n                onAfterEnter && onAfterEnter(el);\n            }\n        }\n        set1(_el);\n    }\n    function exitTransition(_el) {\n        const exitClasses = getClassState(\"exit\");\n        const exitActiveClasses = getClassState(\"exit-active\");\n        const exitToClasses = getClassState(\"exit-to\");\n        const el = getElement(_el);\n        if (!_el.parentNode)\n            return endTransition();\n        onBeforeExit && onBeforeExit(_el);\n        el.classList.add(...exitClasses);\n        el.classList.add(...exitActiveClasses);\n        requestAnimationFrame(() => {\n            el.classList.remove(...exitClasses);\n            el.classList.add(...exitToClasses);\n        });\n        onExit && onExit(el, endTransition);\n        if (!onExit || onExit.length < 2) {\n            el.addEventListener(\"transitionend\", endTransition, { once: true });\n            el.addEventListener(\"animationend\", endTransition, { once: true });\n        }\n        function endTransition() {\n            el.classList.remove(...exitActiveClasses);\n            el.classList.remove(...exitToClasses);\n            s1() === _el && set1(undefined);\n            onAfterExit && onAfterExit(el);\n        }\n    }\n    createComputed((prev) => {\n        el = resolved();\n        while (typeof el === \"function\")\n            el = el();\n        return untrack(() => {\n            if (el && el !== prev) {\n                enterTransition(el, prev);\n            }\n            if (prev && prev !== el)\n                exitTransition(prev);\n            first = false;\n            return el;\n        });\n    });\n    return [s1];\n};\n","import { removeMenuButtonEvents } from \"./menuButton\";\nexport const removeLocalEvents = (state, { onCleanup = false } = {}) => {\n    document.removeEventListener(\"click\", state.onClickDocumentRef);\n    removeMenuButtonEvents(state, onCleanup);\n};\n","import { dismissStack } from \"../global/dismissStack\";\nimport { globalState, onDocumentClick } from \"../global/globalEvents\";\nimport { queryElement } from \"../utils\";\n// Safari, if relatedTarget is not contained within focusout, it will be null\nexport const onFocusOutContainer = (state, e) => {\n    const { overlay, overlayElement, open, mount, setOpen, timeouts, stopComponentEventPropagation, focusedMenuBtn, } = state;\n    const relatedTarget = e.relatedTarget;\n    if (overlay)\n        return;\n    if (overlayElement)\n        return;\n    if (!open())\n        return;\n    if (globalState.closedBySetOpen) {\n        return;\n    }\n    if (mount && stopComponentEventPropagation) {\n        if (!globalState.addedDocumentClick) {\n            globalState.addedDocumentClick = true;\n            document.addEventListener(\"click\", onDocumentClick, { once: true });\n        }\n        return;\n    }\n    if (!relatedTarget) {\n        if (dismissStack.find((item) => item.overlay))\n            return;\n        if (!globalState.addedDocumentClick) {\n            globalState.addedDocumentClick = true;\n            document.addEventListener(\"click\", onDocumentClick, { once: true });\n        }\n        return;\n    }\n    timeouts.containerFocusTimeoutId = window.setTimeout(() => {\n        globalState.closedByEvents = true;\n        setOpen(false);\n    });\n};\nexport const onFocusInContainer = (state, e) => {\n    const { timeouts } = state;\n    clearTimeout(timeouts.containerFocusTimeoutId);\n    clearTimeout(timeouts.menuButtonBlurTimeoutId);\n    timeouts.containerFocusTimeoutId = null;\n};\nexport const runFocusOnActive = (state) => {\n    const { focusElementOnOpen, focusedMenuBtn } = state;\n    if (focusElementOnOpen == null)\n        return;\n    const el = queryElement(state, {\n        inputElement: focusElementOnOpen,\n        type: \"focusElementOnOpen\",\n    });\n    if (el) {\n        setTimeout(() => {\n            el.focus();\n            focusedMenuBtn.el = null;\n        });\n    }\n};\n","import { dismissStack } from \"../global/dismissStack\";\nimport { globalState } from \"../global/globalEvents\";\nimport { checkThenClose, queryElement } from \"../utils\";\nimport { getMenuButton } from \"./menuButton\";\nexport const onClickOverlay = (state) => {\n    const { closeWhenOverlayClicked, menuPopupEl, focusElementOnClose, menuBtnEls, } = state;\n    if (!closeWhenOverlayClicked) {\n        menuPopupEl.focus();\n        return;\n    }\n    const menuBtnEl = getMenuButton(menuBtnEls);\n    const el = queryElement(state, {\n        inputElement: focusElementOnClose,\n        type: \"focusElementOnClose\",\n        subType: \"click\",\n    }) || menuBtnEl;\n    if (el) {\n        el.focus();\n    }\n    checkThenClose(dismissStack, (item) => {\n        if (item.overlayElement)\n            return;\n        return item;\n    }, (item) => {\n        const { setOpen } = item;\n        globalState.closedByEvents = true;\n        setOpen(false);\n    });\n    globalState.closedByEvents = true;\n    state.setOpen(false);\n};\n","import { dismissStack } from \"../global/dismissStack\";\nimport { globalState } from \"../global/globalEvents\";\nimport { checkThenClose, matchByFirstChild, queryElement } from \"../utils\";\nimport { getNextTabbableElement } from \"../utils/tabbing\";\nimport { getMenuButton } from \"./menuButton\";\nexport const activateLastFocusSentinel = (state) => {\n    const { enableLastFocusSentinel, menuBtnEls, containerEl, focusSentinelAfterEl, } = state;\n    if (enableLastFocusSentinel)\n        return;\n    const menuBtnEl = getMenuButton(menuBtnEls);\n    const menuBtnSibling = menuBtnEl.nextElementSibling;\n    if (matchByFirstChild({\n        parent: menuBtnSibling,\n        matchEl: containerEl,\n    }))\n        return;\n    focusSentinelAfterEl.setAttribute(\"tabindex\", \"0\");\n};\nexport const onFocusSentinel = (state, type, relatedTarget) => {\n    const { uniqueId, containerEl, menuBtnEls, focusSentinelBeforeEl, trapFocus, focusSentinelAfterEl, closeWhenMenuButtonIsTabbed, focusElementOnClose, mount, open, setOpen, } = state;\n    const menuBtnEl = getMenuButton(menuBtnEls);\n    // clearTimeout(containerFocusTimeoutId!);\n    // if (mount) {\n    dismissStack.forEach((item) => window.clearTimeout(item.timeouts.containerFocusTimeoutId));\n    // }\n    const runIfMounted = (el, isFirst) => {\n        // globalState.closeByFocusSentinel = true;\n        checkThenClose(dismissStack, (item) => {\n            if (isFirst) {\n                if (getMenuButton(item.menuBtnEls) === el &&\n                    !item.closeWhenMenuButtonIsTabbed) {\n                    menuBtnEl.addEventListener(\"focus\", state.onFocusMenuButtonRef, {\n                        once: true,\n                    });\n                    menuBtnEl.addEventListener(\"keydown\", state.onKeydownMenuButtonRef);\n                    menuBtnEl.addEventListener(\"blur\", state.onBlurMenuButtonRef, {\n                        once: true,\n                    });\n                    return;\n                }\n            }\n            if (item.uniqueId === uniqueId || !item.containerEl.contains(el)) {\n                return item;\n            }\n            return;\n        }, (item) => {\n            globalState.closedByEvents = true;\n            item.setOpen(false);\n        });\n        if (el) {\n            el.focus();\n        }\n    };\n    if (!open())\n        return;\n    if (relatedTarget === containerEl || relatedTarget === menuBtnEl) {\n        const el = getNextTabbableElement({\n            from: focusSentinelBeforeEl,\n            stopAtElement: containerEl,\n        });\n        el.focus();\n        return;\n    }\n    if (type === \"before\") {\n        if (trapFocus) {\n            const el = getNextTabbableElement({\n                from: focusSentinelAfterEl,\n                direction: \"backwards\",\n                stopAtElement: containerEl,\n            });\n            el.focus();\n            return;\n        }\n        if (closeWhenMenuButtonIsTabbed) {\n            globalState.closedByEvents = true;\n            setOpen(false);\n            menuBtnEl.focus();\n            return;\n        }\n        const el = queryElement(state, {\n            inputElement: focusElementOnClose,\n            type: \"focusElementOnClose\",\n            subType: \"tabBackwards\",\n        }) || menuBtnEl;\n        runIfMounted(el, true);\n        return;\n    }\n    if (trapFocus) {\n        const el = getNextTabbableElement({\n            from: focusSentinelBeforeEl,\n            stopAtElement: containerEl,\n        });\n        el.focus();\n        return;\n    }\n    const el = queryElement(state, {\n        inputElement: focusElementOnClose,\n        type: \"focusElementOnClose\",\n        subType: \"tabForwards\",\n    }) ||\n        getNextTabbableElement({\n            from: menuBtnEl,\n            ignoreElement: [containerEl],\n        });\n    if (mount) {\n        runIfMounted(el);\n        return;\n    }\n    if (el) {\n        el.focus();\n    }\n    globalState.closedByEvents = true;\n    setOpen(false);\n};\n","import \"./browserInfo\";\nimport { untrack, createEffect, onCleanup, on, createUniqueId, createMemo, createComputed, } from \"solid-js\";\nimport { hasDisplayNone, queryElement } from \"./utils\";\nimport { dismissStack, addDismissStack, removeDismissStack, } from \"./global/dismissStack\";\nimport { addGlobalEvents, globalState, onDocumentClick, removeGlobalEvents, } from \"./global/globalEvents\";\nimport { onClickDocument, onFocusFromOutsideAppOrTab, removeOutsideFocusEvents, } from \"./local/outside\";\nimport { addMenuPopupEl, removeMenuPopupEl } from \"./local/menuPopup\";\nimport { getMenuButton, markFocusedMenuButton, onBlurMenuButton, onClickMenuButton, onClickOutsideMenuButton, onFocusMenuButton, onKeydownMenuButton, onMouseDownMenuButton, removeMenuButtonEvents, } from \"./local/menuButton\";\nimport CreatePortal from \"./components/CreatePortal\";\nimport { Transition } from \"./components/Transition\";\nimport { removeLocalEvents } from \"./local/manageLocalEvents\";\nimport { onFocusInContainer, onFocusOutContainer, runFocusOnActive, } from \"./local/container\";\nimport { onClickOverlay } from \"./local/overlay\";\nimport { activateLastFocusSentinel, onFocusSentinel, } from \"./local/focusSentinel\";\n/**\n *\n * Handles \"click outside\" behavior for button popup pairings. Closing is triggered by click/focus outside of popup element or pressing \"Escape\" key.\n */\nconst Dismiss = (props) => {\n    const { id = \"\", menuButton, menuPopup, focusElementOnClose, focusElementOnOpen, cursorKeys = false, closeWhenMenuButtonIsTabbed = false, closeWhenMenuButtonIsClicked = true, closeWhenScrolling = false, closeWhenDocumentBlurs = false, closeWhenOverlayClicked = true, closeWhenEscapeKeyIsPressed = true, overlay = false, overlayElement = false, trapFocus = false, removeScrollbar = false, enableLastFocusSentinel = false, mount, \n    // stopComponentEventPropagation = false,\n    show = false, onOpen, } = props;\n    const state = {\n        mount,\n        addedFocusOutAppEvents: false,\n        closeWhenOverlayClicked,\n        closeWhenDocumentBlurs,\n        closeWhenEscapeKeyIsPressed,\n        closeWhenMenuButtonIsClicked,\n        closeWhenMenuButtonIsTabbed,\n        closeWhenScrolling,\n        cursorKeys,\n        focusElementOnClose,\n        focusElementOnOpen,\n        id,\n        uniqueId: createUniqueId(),\n        menuBtnId: \"\",\n        focusedMenuBtn: { el: null },\n        menuBtnKeyupTabFired: false,\n        menuButton,\n        timeouts: {\n            containerFocusTimeoutId: null,\n            menuButtonBlurTimeoutId: null,\n        },\n        upperStackRemovedByFocusOut: false,\n        menuPopup,\n        closeByDismissEvent: false,\n        menuPopupAdded: false,\n        enableLastFocusSentinel,\n        overlay,\n        overlayElement,\n        removeScrollbar,\n        trapFocus,\n        hasFocusSentinels: !!focusElementOnClose ||\n            overlay ||\n            !!overlayElement ||\n            trapFocus ||\n            enableLastFocusSentinel,\n        open: props.open,\n        setOpen: props.setOpen,\n        onClickOutsideMenuButtonRef: () => onClickOutsideMenuButton(state),\n        onClickDocumentRef: (e) => onClickDocument(state, e),\n        onClickOverlayRef: () => onClickOverlay(state),\n        onFocusInContainerRef: (e) => onFocusInContainer(state, e),\n        onFocusOutContainerRef: (e) => onFocusOutContainer(state, e),\n        onBlurMenuButtonRef: (e) => onBlurMenuButton(state, e),\n        onClickMenuButtonRef: (e) => onClickMenuButton(state, e),\n        onMouseDownMenuButtonRef: (e) => onMouseDownMenuButton(state, e),\n        onFocusFromOutsideAppOrTabRef: (e) => onFocusFromOutsideAppOrTab(state, e),\n        onFocusMenuButtonRef: () => onFocusMenuButton(state),\n        onKeydownMenuButtonRef: (e) => onKeydownMenuButton(state, e),\n        refContainerCb: (el) => {\n            if (overlayElement) {\n                el.style.zIndex = \"1000\";\n            }\n            if (props.ref) {\n                // @ts-ignore\n                props.ref(el);\n            }\n            state.containerEl = el;\n        },\n        refOverlayCb: (el) => {\n            el.style.position = \"fixed\";\n            el.style.top = \"0\";\n            el.style.left = \"0\";\n            el.style.width = \"100%\";\n            el.style.height = \"100%\";\n            el.style.zIndex = \"1000\";\n            if (typeof overlayElement === \"object\" && overlayElement.ref) {\n                overlayElement.ref(el);\n            }\n            state.overlayEl = el;\n        },\n    };\n    let marker = mount ? document.createTextNode(\"\") : null;\n    const initDefer = !props.open();\n    let containerEl;\n    let mountEl;\n    let endExitTransitionRef;\n    let endEnterTransitionRef;\n    let endExitTransitionOverlayRef;\n    let endEnterTransitionOverlayRef;\n    let exitRunning = false;\n    function getElement(el, appendToElement) {\n        if (appendToElement) {\n            if (appendToElement === \"menuPopup\") {\n                return queryElement({ containerEl: el }, { inputElement: null, type: \"menuPopup\" });\n            }\n            return typeof appendToElement === \"string\"\n                ? el.querySelector(appendToElement)\n                : appendToElement;\n        }\n        return el;\n    }\n    function enterTransition(type, el) {\n        // @ts-ignore\n        if (type === \"overlay\" && (!props.overlay || !props.overlay.animation))\n            return;\n        const animation = type === \"popup\"\n            ? props.animation // @ts-ignore\n            : props.overlay.animation;\n        if (!animation)\n            return;\n        if (!animation.appear && !initDefer)\n            return;\n        exitRunning = false;\n        el = getElement(el, animation.appendToElement);\n        const name = animation.name;\n        let { onBeforeEnter, onEnter, onAfterEnter, enterActiveClass = name + \"-enter-active\", enterClass = name + \"-enter\", enterToClass = name + \"-enter-to\", exitActiveClass = name + \"-exit-active\", exitClass = name + \"-exit\", exitToClass = name + \"-exit-to\", } = animation;\n        const enterClasses = enterClass.split(\" \");\n        const enterActiveClasses = enterActiveClass.split(\" \");\n        const enterToClasses = enterToClass.split(\" \");\n        const exitClasses = exitClass.split(\" \");\n        const exitActiveClasses = exitActiveClass.split(\" \");\n        const exitToClasses = exitToClass.split(\" \");\n        if (type === \"popup\") {\n            el.removeEventListener(\"transitionend\", endExitTransitionRef);\n            el.removeEventListener(\"animationend\", endExitTransitionRef);\n        }\n        else {\n            el.removeEventListener(\"transitionend\", endExitTransitionOverlayRef);\n            el.removeEventListener(\"animationend\", endExitTransitionOverlayRef);\n        }\n        onBeforeEnter && onBeforeEnter(el);\n        el.classList.remove(...exitClasses, ...exitActiveClasses, ...exitToClasses);\n        el.classList.add(...enterClasses);\n        el.classList.add(...enterActiveClasses);\n        requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n                el.classList.remove(...enterClasses);\n                el.classList.add(...enterToClasses);\n                onEnter && onEnter(el, endTransition);\n                if (!onEnter || onEnter.length < 2) {\n                    if (type === \"popup\") {\n                        endEnterTransitionRef = endTransition;\n                    }\n                    else {\n                        endEnterTransitionOverlayRef = endTransition;\n                    }\n                    el.addEventListener(\"transitionend\", endTransition, {\n                        once: true,\n                    });\n                    el.addEventListener(\"animationend\", endTransition, {\n                        once: true,\n                    });\n                }\n            });\n        });\n        function endTransition() {\n            if (el) {\n                el.classList.remove(...enterActiveClasses);\n                el.classList.remove(...enterToClasses);\n                onAfterEnter && onAfterEnter(el);\n            }\n        }\n    }\n    function exitTransition(type, el) {\n        if (!props.animation) {\n            mountEl?.removeChild(containerEl);\n            containerEl = null;\n            mountEl = null;\n            return;\n        }\n        // @ts-ignore\n        if (type === \"overlay\" && (!props.overlay || !props.overlay.animation))\n            return;\n        // @ts-ignore\n        const animation = type === \"popup\"\n            ? props.animation\n            : // @ts-ignore\n                props.overlay.animation;\n        exitRunning = true;\n        el = getElement(el, animation.appendToElement);\n        const name = animation.name;\n        let { onBeforeExit, onExit, onAfterExit, exitActiveClass = name + \"-exit-active\", exitClass = name + \"-exit\", exitToClass = name + \"-exit-to\", } = animation;\n        const exitClasses = exitClass.split(\" \");\n        const exitActiveClasses = exitActiveClass.split(\" \");\n        const exitToClasses = exitToClass.split(\" \");\n        if (type === \"popup\") {\n            el.removeEventListener(\"transitionend\", endEnterTransitionRef);\n            el.removeEventListener(\"animationend\", endEnterTransitionRef);\n        }\n        else {\n            el.removeEventListener(\"transitionend\", endEnterTransitionOverlayRef);\n            el.removeEventListener(\"animationend\", endEnterTransitionOverlayRef);\n        }\n        if (!el.parentNode)\n            return endTransition();\n        onBeforeExit && onBeforeExit(el);\n        el.classList.add(...exitClasses);\n        el.classList.add(...exitActiveClasses);\n        requestAnimationFrame(() => {\n            el.classList.remove(...exitClasses);\n            el.classList.add(...exitToClasses);\n        });\n        onExit && onExit(el, endTransition);\n        if (!onExit || onExit.length < 2) {\n            if (type === \"popup\") {\n                endExitTransitionRef = endTransition;\n            }\n            else {\n                endExitTransitionOverlayRef = endTransition;\n            }\n            el.addEventListener(\"transitionend\", endTransition, { once: true });\n            el.addEventListener(\"animationend\", endTransition, { once: true });\n        }\n        function endTransition() {\n            exitRunning = false;\n            mountEl?.removeChild(containerEl);\n            globalState.closedBySetOpen = false;\n            if (state.menuBtnEls && (overlay || overlayElement)) {\n                if (document.activeElement === document.body) {\n                    const menuBtnEl = getMenuButton(state.menuBtnEls);\n                    menuBtnEl.focus();\n                }\n            }\n            onAfterExit && onAfterExit(el);\n            containerEl = null;\n            mountEl = null;\n        }\n    }\n    const runRemoveScrollbar = (open) => {\n        if (!removeScrollbar)\n            return;\n        if (dismissStack.length > 1)\n            return;\n        if (open) {\n            const el = document.scrollingElement;\n            el.style.overflow = \"hidden\";\n        }\n        else {\n            const el = document.scrollingElement;\n            el.style.overflow = \"\";\n        }\n    };\n    const resetFocusOnClose = () => {\n        const activeElement = document.activeElement;\n        if (activeElement !== document.body) {\n            if (state.menuBtnEls.every((menuBtnEl) => activeElement !== menuBtnEl) &&\n                !state.containerEl?.contains(activeElement)) {\n                return;\n            }\n        }\n        const { menuBtnEls, focusedMenuBtn, timeouts } = state;\n        const menuBtnEl = getMenuButton(menuBtnEls);\n        const el = queryElement(state, {\n            inputElement: focusElementOnClose,\n            type: \"focusElementOnClose\",\n            subType: \"click\",\n        }) || menuBtnEl;\n        if (el) {\n            el.focus();\n            if (el === menuBtnEl) {\n                markFocusedMenuButton({ focusedMenuBtn, timeouts, el });\n            }\n        }\n    };\n    const programmaticRemoval = () => {\n        if (globalState.closedByEvents)\n            return;\n        const activeElement = document.activeElement;\n        if (\n        // activeElement !== state.menuBtnEls\n        state.menuBtnEls.every((menuBtnEl) => activeElement !== menuBtnEl) &&\n            !state.containerEl?.contains(activeElement)) {\n            setTimeout(() => {\n                globalState.closedBySetOpen = false;\n            });\n            return;\n        }\n        if (!globalState.closedBySetOpen) {\n            globalState.addedDocumentClick = false;\n            document.removeEventListener(\"click\", onDocumentClick);\n            globalState.closedBySetOpen = true;\n            setTimeout(() => {\n                globalState.closedBySetOpen = false;\n                resetFocusOnClose();\n            });\n        }\n    };\n    createEffect(on(() => typeof props.menuButton === \"function\"\n        ? props.menuButton()\n        : props.menuButton, (menuButton) => {\n        if (Array.isArray(menuButton) && !menuButton.length)\n            return;\n        const { focusedMenuBtn } = state;\n        const menuBtnEls = queryElement(state, {\n            inputElement: menuButton,\n            type: \"menuButton\",\n        });\n        if (!menuBtnEls)\n            return;\n        state.menuBtnEls = Array.isArray(menuBtnEls)\n            ? menuBtnEls\n            : [menuBtnEls];\n        state.menuBtnEls.forEach((menuBtnEl, _, self) => {\n            if (focusedMenuBtn.el &&\n                focusedMenuBtn.el !== menuBtnEl &&\n                (self.length > 1 ? !hasDisplayNone(menuBtnEl) : true)) {\n                focusedMenuBtn.el = menuBtnEl;\n                menuBtnEl.focus({ preventScroll: true });\n                menuBtnEl.addEventListener(\"keydown\", state.onKeydownMenuButtonRef);\n            }\n            menuBtnEl.setAttribute(\"type\", \"button\");\n            menuBtnEl.addEventListener(\"click\", state.onClickMenuButtonRef);\n            menuBtnEl.addEventListener(\"mousedown\", state.onMouseDownMenuButtonRef);\n            if (props.open() &&\n                (!state.focusElementOnOpen ||\n                    state.focusElementOnOpen === \"menuButton\" ||\n                    state.focusElementOnOpen === state.menuBtnEls) &&\n                !hasDisplayNone(menuBtnEl)) {\n                menuBtnEl.addEventListener(\"blur\", state.onBlurMenuButtonRef, {\n                    once: true,\n                });\n            }\n        });\n        const item = dismissStack.find((item) => item.uniqueId === state.uniqueId);\n        if (item) {\n            item.menuBtnEls = state.menuBtnEls;\n        }\n        onCleanup(() => {\n            if (!state)\n                return;\n            removeMenuButtonEvents(state, true);\n        });\n    }));\n    if (show && mount) {\n        CreatePortal({\n            mount: typeof mount === \"string\" ? document.querySelector(mount) : mount,\n            popupChildren: render(props.children),\n            overlayChildren: overlayElement ? renderOverlay() : null,\n            marker,\n            onCreate: (mount, container) => {\n                mountEl = mount;\n                containerEl = container;\n            },\n        });\n    }\n    createComputed(on(() => !!props.open(), (open, prevOpen) => {\n        if (open === prevOpen)\n            return;\n        if (!open) {\n            if (state.focusSentinelAfterEl) {\n                state.focusSentinelAfterEl.tabIndex = -1;\n            }\n            programmaticRemoval();\n        }\n        if (!mount || show)\n            return;\n        if (open) {\n            if (!mountEl) {\n                CreatePortal({\n                    mount: typeof mount === \"string\"\n                        ? document.querySelector(mount)\n                        : mount,\n                    popupChildren: render(props.children),\n                    overlayChildren: overlayElement ? renderOverlay() : null,\n                    marker,\n                    onCreate: (mount, container) => {\n                        mountEl = mount;\n                        containerEl = container;\n                    },\n                });\n            }\n            enterTransition(\"popup\", containerEl?.firstElementChild);\n            enterTransition(\"overlay\", state.overlayEl);\n        }\n        else {\n            exitTransition(\"popup\", containerEl?.firstElementChild);\n            exitTransition(\"overlay\", state.overlayEl);\n        }\n    }, { defer: initDefer }));\n    createEffect(on(() => !!props.open(), (open, prevOpen) => {\n        if (open === prevOpen)\n            return;\n        if (open) {\n            globalState.closedByEvents = false;\n            addMenuPopupEl(state);\n            runFocusOnActive(state);\n            addGlobalEvents(closeWhenScrolling);\n            addDismissStack({\n                id,\n                uniqueId: state.uniqueId,\n                open: props.open,\n                setOpen: props.setOpen,\n                containerEl: state.containerEl,\n                menuBtnEls: state.menuBtnEls,\n                focusedMenuBtn: state.focusedMenuBtn,\n                overlayEl: state.overlayEl,\n                menuPopupEl: state.menuPopupEl,\n                overlay,\n                closeWhenDocumentBlurs,\n                closeWhenEscapeKeyIsPressed,\n                closeWhenMenuButtonIsTabbed,\n                overlayElement,\n                cursorKeys,\n                focusElementOnClose,\n                focusSentinelBeforeEl: state.focusSentinelBeforeEl,\n                upperStackRemovedByFocusOut: false,\n                detectIfMenuButtonObscured: false,\n                queueRemoval: false,\n                timeouts: state.timeouts,\n            });\n            runRemoveScrollbar(open);\n            onOpen && onOpen(open, { uniqueId: state.uniqueId, dismissStack });\n            activateLastFocusSentinel(state);\n        }\n        else {\n            globalState.closedByEvents = false;\n            removeLocalEvents(state);\n            removeOutsideFocusEvents(state);\n            removeMenuPopupEl(state);\n            removeDismissStack(state.uniqueId);\n            removeGlobalEvents();\n            runRemoveScrollbar(open);\n            onOpen && onOpen(open, { uniqueId: state.uniqueId, dismissStack });\n        }\n    }, { defer: initDefer }));\n    onCleanup(() => {\n        removeLocalEvents(state, { onCleanup: true });\n        removeMenuPopupEl(state);\n        removeOutsideFocusEvents(state);\n        removeDismissStack(state.uniqueId);\n        removeGlobalEvents();\n        if (!show && mount && mountEl && !exitRunning) {\n            exitTransition(\"popup\", containerEl?.firstElementChild);\n            exitTransition(\"overlay\", state.overlayEl);\n        }\n    });\n    function renderOverlay() {\n        return (<div class={typeof props.overlayElement === \"object\"\n                ? props.overlayElement.class\n                : undefined} classList={typeof props.overlayElement === \"object\"\n                ? props.overlayElement.classList || {}\n                : {}} role=\"presentation\" onClick={state.onClickOverlayRef} ref={state.refOverlayCb}></div>);\n    }\n    function render(children) {\n        return (<div id={state.id} class={props.class} classList={props.classList || {}} onFocusIn={state.onFocusInContainerRef} onFocusOut={state.onFocusOutContainerRef} ref={state.refContainerCb}>\n        <div tabindex={props.open() ? \"0\" : \"-1\"} onFocus={(e) => {\n                onFocusSentinel(state, \"before\", e.relatedTarget);\n            }} style=\"position: fixed; top: 0; left: 0; outline: none; pointer-events: none; width: 0; height: 0;\" aria-hidden=\"true\" ref={state.focusSentinelBeforeEl}></div>\n        {children}\n        <div tabindex={props.open() && state.hasFocusSentinels ? \"0\" : \"-1\"} onFocus={() => {\n                onFocusSentinel(state, \"after\");\n            }} style=\"position: fixed; top: 0; left: 0; outline: none; pointer-events: none; width: 0; height: 0;\" aria-hidden=\"true\" ref={state.focusSentinelAfterEl}></div>\n      </div>);\n    }\n    if (props.mount)\n        return marker;\n    if (show)\n        return render(props.children);\n    let strictEqual = false;\n    const condition = createMemo(() => props.open(), undefined, {\n        equals: (a, b) => (strictEqual ? a === b : !a === !b),\n    });\n    const finalRender = createMemo(() => {\n        const c = condition();\n        if (c) {\n            const child = props.children;\n            return (strictEqual = typeof child === \"function\" && child.length > 0)\n                ? untrack(() => child(c))\n                : render(child);\n        }\n    });\n    if (props.animation) {\n        return (<Transition {...props.animation} name={props.animation.name} enterClass={props.animation.enterClass} enterActiveClass={props.animation.enterActiveClass} enterToClass={props.animation.enterToClass} exitClass={props.animation.exitClass} exitActiveClass={props.animation.exitActiveClass} exitToClass={props.animation.exitToClass} appear={props.animation.appear}>\n        {finalRender()}\n      </Transition>);\n    }\n    return finalRender;\n};\nexport default Dismiss;\n","var resizeObservers = [];\nexport { resizeObservers };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasActiveObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\nexport { hasActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasSkippedObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\nexport { hasSkippedObservations };\n","var msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n","var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n","export var freeze = function (obj) { return Object.freeze(obj); };\n","import { freeze } from './utils/freeze';\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        freeze(this);\n    }\n    return ResizeObserverSize;\n}());\nexport { ResizeObserverSize };\n","import { freeze } from './utils/freeze';\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return freeze(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\nexport { DOMRectReadOnly };\n","var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a, _b;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\nexport { isSVG, isHidden, isElement, isReplacedElement };\n","export var global = typeof window !== 'undefined' ? window : {};\n","import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { ResizeObserverSize } from '../ResizeObserverSize';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nimport { isSVG, isHidden } from '../utils/element';\nimport { freeze } from '../utils/freeze';\nimport { global } from '../utils/global';\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if (isHidden(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = freeze({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes };\n","import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nimport { freeze } from './utils/freeze';\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\nexport { ResizeObserverEntry };\n","import { isHidden } from '../utils/element';\nvar calculateDepthForNode = function (node) {\n    if (isHidden(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new ResizeObserverEntry(ot.target);\n            var targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nvar gatherActiveObservationsAtDepth = function (depth) {\n    resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n","import { hasActiveObservations } from '../algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from '../algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from '../algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from '../algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from '../algorithms/gatherActiveObservationsAtDepth';\nvar process = function () {\n    var depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport { process };\n","var trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\" + (toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\nexport { queueMicroTask };\n","import { queueMicroTask } from './queueMicroTask';\nvar queueResizeObserver = function (cb) {\n    queueMicroTask(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\nexport { queueResizeObserver };\n","import { process } from './process';\nimport { global } from './global';\nimport { queueResizeObserver } from './queueResizeObserver';\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        queueResizeObserver(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = process();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\nexport { scheduler, updateCount };\n","import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nimport { isSVG, isReplacedElement } from './utils/element';\nvar skipNotifyOnElement = function (target) {\n    return !isSVG(target)\n        && !isReplacedElement(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = calculateBoxSize(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\nexport { ResizeObservation };\n","var ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\nexport { ResizeObserverDetail };\n","import { scheduler, updateCount } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { resizeObservers } from './utils/resizeObservers';\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && resizeObservers.push(detail);\n            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n            updateCount(1);\n            scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            updateCount(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\nexport { ResizeObserverController };\n","import { ResizeObserverController } from './ResizeObserverController';\nimport { isElement } from './utils/element';\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\nexport { ResizeObserver };\n"],"names":["Transition","Router","props","source","url","base","data","out","integration","pathIntegration","routerState","createRouterContext","children","Routes","router","useRouter","parentRoute","useRoute","branches","createMemo","createBranches","joinPaths","pattern","Outlet","matches","getRouteMatches","location","pathname","push","map","route","path","params","originalPath","disposers","root","routeStates","on","nextMatches","prevMatches","prev","equal","length","next","i","len","prevMatch","nextMatch","createRoot","dispose","createRouteContext","splice","forEach","outlet","Route","child","rest","splitProps","navigate","useNavigate","href","useHref","to","handleClick","evt","onClick","target","undefined","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","resolve","replace","scroll","noScroll","state","useResolvedPath","mergeProps","activeClass","useLocation","isActive","to_","split","toLowerCase","loc","end","startsWith","this","global","Dismiss","id","menuButton","menuPopup","focusElementOnClose","focusElementOnOpen","cursorKeys","closeWhenMenuButtonIsTabbed","closeWhenMenuButtonIsClicked","closeWhenScrolling","closeWhenDocumentBlurs","closeWhenOverlayClicked","closeWhenEscapeKeyIsPressed","overlay","overlayElement","trapFocus","removeScrollbar","enableLastFocusSentinel","mount","show","onOpen","addedFocusOutAppEvents","uniqueId","createUniqueId","menuBtnId","focusedMenuBtn","el","menuBtnKeyupTabFired","timeouts","containerFocusTimeoutId","menuButtonBlurTimeoutId","upperStackRemovedByFocusOut","closeByDismissEvent","menuPopupAdded","hasFocusSentinels","open","setOpen","onClickOutsideMenuButtonRef","onClickOutsideMenuButton","onClickDocumentRef","e","onClickDocument","onClickOverlayRef","onClickOverlay","onFocusInContainerRef","onFocusInContainer","onFocusOutContainerRef","onFocusOutContainer","onBlurMenuButtonRef","onBlurMenuButton","onClickMenuButtonRef","onClickMenuButton","onMouseDownMenuButtonRef","onMouseDownMenuButton","onFocusFromOutsideAppOrTabRef","onFocusFromOutsideAppOrTab","onFocusMenuButtonRef","onFocusMenuButton","onKeydownMenuButtonRef","onKeydownMenuButton","refContainerCb","style","zIndex","ref","containerEl","refOverlayCb","position","top","left","width","height","overlayEl","marker","document","createTextNode","initDefer","mountEl","endExitTransitionRef","endEnterTransitionRef","endExitTransitionOverlayRef","endEnterTransitionOverlayRef","exitRunning","appendToElement","queryElement","inputElement","type","querySelector","animation","appear","getElement","name","onBeforeEnter","onEnter","onAfterEnter","enterActiveClass","enterClass","enterToClass","exitActiveClass","exitClass","exitToClass","enterClasses","enterActiveClasses","enterToClasses","exitClasses","exitActiveClasses","exitToClasses","removeEventListener","classList","remove","add","requestAnimationFrame","endTransition","addEventListener","once","removeChild","onBeforeExit","onExit","onAfterExit","parentNode","globalState","closedBySetOpen","menuBtnEls","activeElement","body","menuBtnEl","getMenuButton","focus","runRemoveScrollbar","dismissStack","scrollingElement","overflow","resetFocusOnClose","every","contains","subType","markFocusedMenuButton","programmaticRemoval","closedByEvents","setTimeout","addedDocumentClick","onDocumentClick","createEffect","Array","isArray","_","self","hasDisplayNone","preventScroll","setAttribute","item","find","onCleanup","removeMenuButtonEvents","CreatePortal","popupChildren","render","overlayChildren","renderOverlay","onCreate","container","createComputed","prevOpen","focusSentinelAfterEl","tabIndex","enterTransition","firstElementChild","exitTransition","defer","addMenuPopupEl","runFocusOnActive","addGlobalEvents","addDismissStack","menuPopupEl","focusSentinelBeforeEl","detectIfMenuButtonObscured","queueRemoval","activateLastFocusSentinel","removeLocalEvents","removeOutsideFocusEvents","removeMenuPopupEl","removeDismissStack","removeGlobalEvents","class","onFocusSentinel","relatedTarget","strictEqual","condition","equals","a","b","finalRender","c","untrack"],"mappings":"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"}